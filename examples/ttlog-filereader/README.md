# TTLog File Reader - Snapshot Analysis Tool

A powerful utility for reading, analyzing, and understanding TTLog snapshot files. This tool helps you decompress, decode, and analyze the compressed snapshot files generated by TTLog applications.

## üéØ What This Tool Does

### üìñ Snapshot Reading
- **Decompress LZ4 compressed files** - Handle the compressed snapshot format
- **Decode CBOR data** - Convert binary data back to structured information
- **Display human-readable output** - Format events for easy analysis

### üìä Analysis Features
- **Event Statistics** - Count events by level, time range, and target
- **Pattern Recognition** - Identify common event patterns and anomalies
- **Time Analysis** - Understand event timing and duration
- **Metadata Extraction** - Access service information and snapshot details

### üîç Utility Functions
- **List Available Snapshots** - Find all snapshot files in `/tmp/`
- **Basic Information Display** - Show snapshot metadata without full analysis
- **Programmatic Access** - Use as a library in other applications

## üöÄ Quick Start

### Prerequisites
```bash
# Ensure you have Rust installed
rustc --version

# Navigate to the example directory
cd examples/ttlog-filereader
```

### Running the Tool
```bash
# List all available snapshots
cargo run -- --list

# Read a specific snapshot file
cargo run /tmp/ttlog-12345-20250101123456-startup.bin

# Run tests
cargo test
```

## üìä Usage Examples

### Listing Available Snapshots
```bash
$ cargo run -- --list

TTLog Snapshot Reader
Usage: ttlog-filereader <snapshot_file_path>
   or: ttlog-filereader --list

Snapshot files found:
  /tmp/ttlog-12345-20250101123456-startup.bin
    -> 45 events, reason: startup, created: 2025-01-01 12:34:56 UTC
  /tmp/ttlog-12345-20250101123457-panic.bin
    -> 12 events, reason: panic, created: 2025-01-01 12:34:57 UTC
  /tmp/ttlog-12345-20250101123458-high_load.bin
    -> 234 events, reason: high_load, created: 2025-01-01 12:34:58 UTC
```

### Reading a Specific Snapshot
```bash
$ cargo run /tmp/ttlog-12345-20250101123456-startup.bin

Reading snapshot file: /tmp/ttlog-12345-20250101123456-startup.bin
Compressed file size: 2048 bytes
Decompressed size: 8192 bytes

=== SNAPSHOT DETAILS ===
Service: my-application
Hostname: server-01
PID: 12345
Created At: 2025-01-01 12:34:56 UTC
Reason: startup
Event Count: 45

=== EVENTS ===
Event #1: [INFO] Application started - my_app (2025-01-01 12:34:56.123 UTC)
Event #2: [INFO] Configuration loaded - config (2025-01-01 12:34:56.124 UTC)
Event #3: [DEBUG] Database connection established - db (2025-01-01 12:34:56.125 UTC)
Event #4: [INFO] Server listening on port 8080 - server (2025-01-01 12:34:56.126 UTC)
Event #5: [WARN] High memory usage detected - monitor (2025-01-01 12:34:56.127 UTC)
...

=== ANALYSIS ===
Events by level:
  INFO: 25
  DEBUG: 15
  WARN: 3
  ERROR: 2

Time range: 45 ms
First event: 2025-01-01 12:34:56.123 UTC
Last event: 2025-01-01 12:34:56.168 UTC

Unique targets: 4
Targets:
  my_app
  config
  db
  server
```

## üèóÔ∏è Architecture Overview

### Snapshot Structure
```rust
#[derive(Serialize, Deserialize, Clone, Debug)]
struct Snapshot {
    pub service: String,        // Service name
    pub hostname: String,       // Host machine name
    pub pid: u32,              // Process ID
    pub created_at: String,    // Creation timestamp
    pub reason: String,        // Snapshot reason
    pub events: Vec<Event>,    // List of events
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Event {
    pub timestamp: u64,        // Event timestamp (milliseconds)
    pub level: String,         // Log level (INFO, DEBUG, WARN, ERROR)
    pub message: String,       // Event message
    pub target: String,        // Event target/module
}
```

### Processing Flow
1. **File Reading** - Read compressed binary file from disk
2. **LZ4 Decompression** - Decompress the data using LZ4 algorithm
3. **CBOR Deserialization** - Convert binary data to structured format
4. **Analysis** - Process events for statistics and patterns
5. **Display** - Format and present results

## üîß API Reference

### Main Functions

#### `read_snapshot_file(file_path: &str) -> Result<Snapshot, Box<dyn std::error::Error>>`
Reads and decompresses a snapshot file.

```rust
let snapshot = read_snapshot_file("/tmp/ttlog-12345-20250101123456-startup.bin")?;
println!("Service: {}", snapshot.service);
println!("Events: {}", snapshot.events.len());
```

#### `list_snapshot_files() -> std::io::Result<Vec<String>>`
Lists all available snapshot files in `/tmp/`.

```rust
let files = list_snapshot_files()?;
for file in files {
    println!("Found snapshot: {}", file);
}
```

#### `display_snapshot(snapshot: &Snapshot)`
Displays formatted snapshot information.

```rust
let snapshot = read_snapshot_file("path/to/snapshot.bin")?;
display_snapshot(&snapshot);
```

#### `analyze_snapshot(snapshot: &Snapshot)`
Performs statistical analysis on snapshot events.

```rust
let snapshot = read_snapshot_file("path/to/snapshot.bin")?;
analyze_snapshot(&snapshot);
```

#### `read_latest_snapshot() -> Result<Snapshot, Box<dyn std::error::Error>>`
Reads the most recent snapshot file.

```rust
let latest = read_latest_snapshot()?;
println!("Latest snapshot: {} events", latest.events.len());
```

## üéØ Use Cases

### 1. Debugging Application Issues
```bash
# Find snapshots related to errors
cargo run -- --list | grep -i error

# Read the most recent error snapshot
cargo run /tmp/ttlog-12345-20250101123457-panic.bin
```

### 2. Performance Analysis
```bash
# Find high-load snapshots
cargo run -- --list | grep -i load

# Analyze performance patterns
cargo run /tmp/ttlog-12345-20250101123458-high_load.bin
```

### 3. Application Monitoring
```bash
# Check recent application activity
cargo run -- --list | tail -5

# Monitor startup sequences
cargo run /tmp/ttlog-12345-20250101123456-startup.bin
```

### 4. Integration with Other Tools
```bash
# Pipe to grep for specific patterns
cargo run /tmp/ttlog-12345-20250101123456-startup.bin | grep "ERROR"

# Count events by level
cargo run /tmp/ttlog-12345-20250101123456-startup.bin | grep "Events by level"
```

## üîß Customization Examples

### Custom Analysis Functions
```rust
fn custom_analysis(snapshot: &Snapshot) {
    // Find slow operations
    let slow_events: Vec<_> = snapshot.events
        .iter()
        .filter(|e| e.message.contains("ms="))
        .collect();
    
    println!("Found {} slow operations", slow_events.len());
    
    // Analyze error patterns
    let errors: Vec<_> = snapshot.events
        .iter()
        .filter(|e| e.level == "ERROR")
        .collect();
    
    println!("Found {} errors", errors.len());
}
```

### Filtering Events
```rust
fn filter_events_by_target(snapshot: &Snapshot, target: &str) {
    let filtered: Vec<_> = snapshot.events
        .iter()
        .filter(|e| e.target == target)
        .collect();
    
    println!("Events for target '{}':", target);
    for event in filtered {
        println!("  [{}] {}", event.level, event.message);
    }
}
```

### Time-based Analysis
```rust
fn analyze_time_distribution(snapshot: &Snapshot) {
    if snapshot.events.is_empty() {
        return;
    }
    
    let timestamps: Vec<u64> = snapshot.events
        .iter()
        .map(|e| e.timestamp)
        .collect();
    
    let min_time = timestamps.iter().min().unwrap();
    let max_time = timestamps.iter().max().unwrap();
    let duration = max_time - min_time;
    
    println!("Event duration: {} ms", duration);
    println!("Average events per second: {:.2}", 
        snapshot.events.len() as f64 / (duration as f64 / 1000.0));
}
```

## üß™ Testing

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test
cargo test test_can_list_snapshot_files
```

### Test Structure
```rust
#[test]
fn test_can_list_snapshot_files() {
    // This test will pass if there are any snapshot files
    // or if the /tmp directory is accessible
    match list_snapshot_files() {
        Ok(_files) => {
            // Test passes if we can list files (even if empty)
            assert!(true);
        },
        Err(e) => {
            panic!("Could not list snapshot files: {}", e);
        },
    }
}
```

## üìà Performance Considerations

### File Size Handling
- **Small snapshots** (< 1MB): Fast processing, immediate display
- **Medium snapshots** (1-10MB): Moderate processing time
- **Large snapshots** (> 10MB): May take several seconds to process

### Memory Usage
- Each event uses ~200-500 bytes in memory
- Large snapshots may require significant memory
- Consider streaming for very large files

### Processing Speed
- LZ4 decompression is very fast
- CBOR deserialization is efficient
- Analysis operations are O(n) where n is event count

## üõ†Ô∏è Troubleshooting

### Common Issues

#### File Not Found
```bash
# Check if file exists
ls -la /tmp/ttlog-*.bin

# Verify file permissions
ls -la /tmp/ttlog-12345-20250101123456-startup.bin
```

#### Corrupted Files
```bash
# Check file size (should be > 0)
ls -lh /tmp/ttlog-12345-20250101123456-startup.bin

# Try reading with error details
RUST_LOG=debug cargo run /tmp/ttlog-12345-20250101123456-startup.bin
```

#### No Snapshots Available
```bash
# Check if any TTLog applications are running
ps aux | grep ttlog

# Verify /tmp directory permissions
ls -la /tmp/
```

### Debug Mode
```bash
# Enable detailed error messages
RUST_LOG=debug cargo run /tmp/ttlog-12345-20250101123456-startup.bin

# Enable trace logging for maximum detail
RUST_LOG=trace cargo run /tmp/ttlog-12345-20250101123456-startup.bin
```

## üîÑ Integration Examples

### As a Library
```rust
use ttlog_filereader::{read_snapshot_file, list_snapshot_files};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // List available snapshots
    let files = list_snapshot_files()?;
    
    // Read the latest snapshot
    if let Some(latest_file) = files.last() {
        let snapshot = read_snapshot_file(latest_file)?;
        println!("Latest snapshot has {} events", snapshot.events.len());
    }
    
    Ok(())
}
```

### With Shell Scripts
```bash
#!/bin/bash
# Monitor for new snapshots
while true; do
    cargo run -- --list | grep -c "ttlog-"
    sleep 10
done
```

### With Monitoring Tools
```bash
# Count total snapshots
TOTAL_SNAPSHOTS=$(cargo run -- --list | grep -c "ttlog-")
echo "Total snapshots: $TOTAL_SNAPSHOTS"

# Check for recent errors
RECENT_ERRORS=$(cargo run -- --list | grep -i error | wc -l)
echo "Recent errors: $RECENT_ERRORS"
```

## üìö Next Steps

After understanding this tool:

1. **Try the Simple Examples** (`../ttlog-simple/`) - Generate snapshots to analyze
2. **Use the Web Server Example** (`../ttlog-server/`) - Create web application snapshots
3. **Explore the Complex Example** (`../ttlog-complex/`) - Analyze complex system snapshots
4. **Integrate into your monitoring pipeline** - Use programmatically

## üéâ Key Takeaways

By using this tool, you'll understand:

- ‚úÖ How to read and analyze TTLog snapshots
- ‚úÖ Event patterns and statistics
- ‚úÖ Performance analysis techniques
- ‚úÖ Debugging with snapshot data
- ‚úÖ Integration with monitoring systems
- ‚úÖ Custom analysis workflows

---

**Ready to analyze your TTLog snapshots? Run `cargo run -- --list` to get started! üîç** 