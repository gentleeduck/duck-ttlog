# TTLog Native Logging System

## Current State Analysis

**Problems with `tracing` dependency:**
- External dependency controls your API surface
- Performance overhead from `tracing`'s generic design
- Limited control over serialization and formatting
- Can't optimize for your specific use cases
- Ecosystem fragmentation (some users want `log`, others `tracing`)

**Solution:** Build your own logging interface that's:
1. **Faster** than existing solutions
2. **More ergonomic** for structured logging  
3. **Compatible** with existing ecosystems
4. **Extensible** for your future telemetry features

## Architecture Overview

```rust
// Core logging interface - zero dependencies
pub mod ttlog {
    pub use ttlog_macros::*;     // Procedural macros
    pub use ttlog_core::*;       // Core types and traits
}

// Optional integrations
pub mod integrations {
    pub mod tracing_compat;      // tracing::Subscriber impl
    pub mod log_compat;          // log::Log impl  
    pub mod slog_compat;         // slog compatibility
}
```

## Phase 1: Core Logging Interface

### Structured Logging Macros
```rust
// ttlog_macros/src/lib.rs - Procedural macros for zero-overhead logging

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Expr, LitStr};

/// Primary logging macro - optimized for structured data
/// 
/// Examples:
/// ttlog::info!("User logged in", user_id = 123, duration_ms = 45);
/// ttlog::error!("Database error", error = %err, query = ?query);
/// ttlog::warn!(user_id = user.id, action = "failed_login", "Authentication failed");
#[proc_macro]
pub fn info(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LogInput);
    let expanded = generate_log_call(&input, LogLevel::Info);
    TokenStream::from(expanded)
}

#[proc_macro]
pub fn warn(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LogInput);
    let expanded = generate_log_call(&input, LogLevel::Warn);
    TokenStream::from(expanded)
}

#[proc_macro]
pub fn error(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LogInput);
    let expanded = generate_log_call(&input, LogLevel::Error);
    TokenStream::from(expanded)
}

#[proc_macro]
pub fn debug(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LogInput);
    let expanded = generate_log_call(&input, LogLevel::Debug);
    TokenStream::from(expanded)
}

#[proc_macro]
pub fn trace(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LogInput);
    let expanded = generate_log_call(&input, LogLevel::Trace);
    TokenStream::from(expanded)
}

// Optimized code generation
fn generate_log_call(input: &LogInput, level: LogLevel) -> proc_macro2::TokenStream {
    let message = &input.message;
    let fields = &input.fields;
    let target = get_module_path();
    
    quote! {
        if ttlog::is_enabled(ttlog::LogLevel::#level, #target) {
            // Pre-allocate capacity based on field count - reduces allocations
            let mut event = ttlog::EventBuilder::with_capacity(#(#fields.len()));
            
            event
                .timestamp(ttlog::now_nanos())
                .level(ttlog::LogLevel::#level)
                .target(#target)
                .message(#message);
            
            // Add fields with compile-time type information
            #(event.field(stringify!(#field_names), #field_values);)*
            
            // Fast path - direct to ring buffer without heap allocation
            ttlog::emit_fast(event.build());
        }
    }
}
```

### Core Types and Runtime
```rust
// ttlog_core/src/lib.rs - Runtime system, zero external dependencies

use std::sync::atomic::{AtomicU64, AtomicBool, Ordering};
use std::collections::HashMap;

/// Log levels - compatible with standard logging
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum LogLevel {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
}

/// Efficient event representation
#[derive(Debug, Clone)]
pub struct LogEvent {
    pub timestamp_nanos: u64,
    pub level: LogLevel,
    pub target: &'static str,
    pub message: String,
    pub fields: SmallVec<[Field; 8]>, // Most events have <8 fields
    pub thread_id: u32,
    pub file: Option<&'static str>,
    pub line: Option<u32>,
}

/// Optimized field storage
#[derive(Debug, Clone)]
pub struct Field {
    pub key: &'static str,
    pub value: FieldValue,
}

/// Efficient value storage - avoid Box/heap allocation for common types
#[derive(Debug, Clone)]
pub enum FieldValue {
    Str(&'static str),
    String(String),
    I64(i64),
    U64(u64),
    F64(f64),
    Bool(bool),
    Debug(String), // For types that only implement Debug
    Display(String), // For types that implement Display
}

/// Zero-allocation event builder
pub struct EventBuilder {
    timestamp_nanos: u64,
    level: LogLevel,
    target: &'static str,
    message: String,
    fields: SmallVec<[Field; 8]>,
}

impl EventBuilder {
    #[inline]
    pub fn with_capacity(field_count: usize) -> Self {
        Self {
            timestamp_nanos: 0,
            level: LogLevel::Info,
            target: "",
            message: String::new(),
            fields: SmallVec::with_capacity(field_count),
        }
    }
    
    #[inline]
    pub fn timestamp(mut self, nanos: u64) -> Self {
        self.timestamp_nanos = nanos;
        self
    }
    
    #[inline]
    pub fn level(mut self, level: LogLevel) -> Self {
        self.level = level;
        self
    }
    
    #[inline]
    pub fn target(mut self, target: &'static str) -> Self {
        self.target = target;
        self
    }
    
    #[inline]
    pub fn message<M: Into<String>>(mut self, msg: M) -> Self {
        self.message = msg.into();
        self
    }
    
    #[inline]
    pub fn field<V: Into<FieldValue>>(mut self, key: &'static str, value: V) -> Self {
        self.fields.push(Field {
            key,
            value: value.into(),
        });
        self
    }
    
    #[inline]
    pub fn build(self) -> LogEvent {
        LogEvent {
            timestamp_nanos: self.timestamp_nanos,
            level: self.level,
            target: self.target,
            message: self.message,
            fields: self.fields,
            thread_id: thread_local_id(),
            file: None, // Set by macro if needed
            line: None,
        }
    }
}

/// Global logging system
static LOGGER: AtomicPtr<dyn Logger> = AtomicPtr::new(std::ptr::null_mut());
static LOG_LEVEL: AtomicU8 = AtomicU8::new(LogLevel::Info as u8);

pub trait Logger: Send + Sync {
    fn emit(&self, event: LogEvent);
    fn flush(&self);
    fn set_level(&self, level: LogLevel);
}

/// Fast path emission - bypasses virtual calls when possible
#[inline]
pub fn emit_fast(event: LogEvent) {
    // Try to avoid virtual call overhead
    if let Some(logger) = get_logger() {
        logger.emit(event);
    }
}

/// Level check - allows compiler to eliminate dead code
#[inline]
pub fn is_enabled(level: LogLevel, target: &str) -> bool {
    let current_level = LogLevel::from_u8(LOG_LEVEL.load(Ordering::Relaxed));
    level >= current_level && is_target_enabled(target)
}

/// High-resolution timestamp
#[inline]
pub fn now_nanos() -> u64 {
    // Platform-specific high-resolution timer
    #[cfg(target_os = "linux")]
    {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
    
    #[cfg(not(target_os = "linux"))]
    {
        // Fallback to coarse timestamp
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
}
```

### Integration with Your Ring Buffer System
```rust
// ttlog_core/src/ring_logger.rs

use crate::{Logger, LogEvent, LogLevel};
use crate::buffer::LockFreeRingBuffer;
use crate::trace::Message;

/// Logger that feeds into your existing ring buffer system
pub struct RingLogger {
    sender: crossbeam_channel::Sender<Message>,
    level: AtomicU8,
}

impl RingLogger {
    pub fn new(sender: crossbeam_channel::Sender<Message>) -> Self {
        Self {
            sender,
            level: AtomicU8::new(LogLevel::Info as u8),
        }
    }
}

impl Logger for RingLogger {
    #[inline]
    fn emit(&self, log_event: LogEvent) {
        // Convert LogEvent to your existing Event type
        let event = crate::event::Event::new(
            log_event.timestamp_nanos / 1_000_000, // Convert to milliseconds
            log_event.level.to_string(),
            log_event.message,
            log_event.target.to_string(),
            log_event.fields.into_iter()
                .map(|f| (f.key.to_string(), f.value.to_json_value()))
                .collect(),
        );
        
        // Non-blocking send to maintain performance
        let _ = self.sender.try_send(Message::Event(event));
    }
    
    fn flush(&self) {
        // Request immediate snapshot
        let _ = self.sender.try_send(Message::SnapshotImmediate("flush".to_string()));
    }
    
    fn set_level(&self, level: LogLevel) {
        self.level.store(level as u8, Ordering::Relaxed);
    }
}

/// Global initialization function
pub fn init() -> TtlogBuilder {
    TtlogBuilder::new()
}

pub struct TtlogBuilder {
    capacity: usize,
    channel_capacity: usize,
    level: LogLevel,
}

impl TtlogBuilder {
    pub fn new() -> Self {
        Self {
            capacity: 1024,
            channel_capacity: 128,
            level: LogLevel::Info,
        }
    }
    
    pub fn capacity(mut self, cap: usize) -> Self {
        self.capacity = cap;
        self
    }
    
    pub fn level(mut self, level: LogLevel) -> Self {
        self.level = level;
        self
    }
    
    pub fn init(self) -> TtlogHandle {
        // Initialize your existing trace system
        let trace = crate::trace::Trace::init(self.capacity, self.channel_capacity);
        
        // Create and install the ring logger
        let logger = Box::new(RingLogger::new(trace.get_sender()));
        install_logger(logger);
        
        // Set global level
        set_level(self.level);
        
        TtlogHandle { trace }
    }
}

pub struct TtlogHandle {
    trace: crate::trace::Trace,
}

impl TtlogHandle {
    pub fn snapshot(&self, reason: &str) {
        self.trace.request_snapshot(reason);
    }
    
    pub fn sender(&self) -> crossbeam_channel::Sender<Message> {
        self.trace.get_sender()
    }
}
```

## Phase 2: Compatibility Layers

### Tracing Compatibility
```rust
// ttlog_integrations/src/tracing_compat.rs
// Allow users to keep using tracing macros but get ttlog performance

use tracing::{Event, Subscriber};
use tracing_subscriber::{Layer, registry::LookupSpan};

pub struct TtlogTracingLayer {
    sender: crossbeam_channel::Sender<crate::trace::Message>,
}

impl TtlogTracingLayer {
    pub fn new(sender: crossbeam_channel::Sender<crate::trace::Message>) -> Self {
        Self { sender }
    }
}

impl<S> Layer<S> for TtlogTracingLayer 
where 
    S: Subscriber + for<'a> LookupSpan<'a>
{
    fn on_event(&self, event: &Event<'_>, _ctx: tracing_subscriber::layer::Context<'_, S>) {
        // Convert tracing::Event to ttlog::LogEvent
        let log_event = convert_tracing_event(event);
        
        // Emit through ttlog system
        ttlog::emit_fast(log_event);
    }
}

/// Migration helper - allows gradual transition
pub fn enable_tracing_compatibility() {
    let layer = TtlogTracingLayer::new(/* your sender */);
    tracing_subscriber::registry()
        .with(layer)
        .init();
}
```

### Log Crate Compatibility  
```rust
// ttlog_integrations/src/log_compat.rs
// Support applications using the `log` crate

use log::{Log, Record, Metadata};

pub struct TtlogLogAdapter {
    sender: crossbeam_channel::Sender<crate::trace::Message>,
}

impl Log for TtlogLogAdapter {
    fn enabled(&self, metadata: &Metadata) -> bool {
        ttlog::is_enabled(
            convert_log_level(metadata.level()),
            metadata.target()
        )
    }
    
    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            let log_event = ttlog::EventBuilder::with_capacity(0)
                .timestamp(ttlog::now_nanos())
                .level(convert_log_level(record.level()))
                .target(record.target())
                .message(record.args().to_string())
                .build();
            
            ttlog::emit_fast(log_event);
        }
    }
    
    fn flush(&self) {
        let _ = self.sender.try_send(crate::trace::Message::SnapshotImmediate("flush".to_string()));
    }
}

/// Easy migration from log crate
pub fn init_with_log_compatibility() -> ttlog::TtlogHandle {
    let handle = ttlog::init().init();
    
    // Install as global log implementation
    let adapter = Box::new(TtlogLogAdapter::new(handle.sender()));
    log::set_boxed_logger(adapter).unwrap();
    log::set_max_level(log::LevelFilter::Trace);
    
    handle
}
```

## Phase 3: Advanced Features

### Structured Logging DSL
```rust
// More ergonomic syntax for complex structured logging

// Using derive macros for automatic field extraction
#[derive(Debug, ttlog::Fields)]
struct LoginAttempt {
    user_id: u64,
    ip_address: String,
    success: bool,
    duration_ms: u64,
}

fn handle_login(attempt: LoginAttempt) {
    // Automatically extracts all fields from the struct
    ttlog::info!(attempt, "Login attempt completed");
    
    // Equivalent to:
    // ttlog::info!(
    //     "Login attempt completed",
    //     user_id = attempt.user_id,
    //     ip_address = attempt.ip_address,
    //     success = attempt.success,
    //     duration_ms = attempt.duration_ms
    // );
}
```

### Async Context Propagation
```rust
// ttlog_core/src/context.rs
// Automatic context propagation in async code

use std::collections::HashMap;
use tokio::task_local;

task_local! {
    static LOG_CONTEXT: HashMap<&'static str, FieldValue>;
}

/// Add context that will be included in all log events in this task
pub fn with_context<K, V, F, R>(key: K, value: V, f: F) -> R
where
    K: Into<&'static str>,
    V: Into<FieldValue>,
    F: FnOnce() -> R,
{
    LOG_CONTEXT.scope(
        {
            let mut ctx = LOG_CONTEXT.try_with(|c| c.clone()).unwrap_or_default();
            ctx.insert(key.into(), value.into());
            ctx
        },
        f
    )
}

// Usage:
async fn process_request(req: Request) -> Response {
    ttlog::with_context("request_id", req.id, || async {
        ttlog::info!("Processing request"); // Automatically includes request_id
        
        let result = database_call().await;
        
        ttlog::info!("Request completed", status = result.status);
        result
    }).await
}
```

### Performance Instrumentation
```rust
// Built-in performance tracking
#[ttlog::instrument] // Automatically logs function entry/exit with timing
async fn expensive_operation(user_id: u64) -> Result<String> {
    ttlog::debug!("Starting expensive operation", user_id = user_id);
    
    let result = heavy_computation().await?;
    
    ttlog::info!("Operation completed", user_id = user_id, result_len = result.len());
    Ok(result)
}

// Expands to:
async fn expensive_operation(user_id: u64) -> Result<String> {
    let _span = ttlog::span!("expensive_operation", user_id = user_id);
    let _timer = ttlog::timer!("expensive_operation_duration");
    
    ttlog::debug!("Starting expensive operation", user_id = user_id);
    
    let result = heavy_computation().await?;
    
    ttlog::info!("Operation completed", user_id = user_id, result_len = result.len());
    Ok(result)
}
```

## Migration Strategy

### Phase 1: Parallel Implementation (2-3 weeks)
1. **Keep existing tracing integration** for backward compatibility
2. **Add ttlog macros** as alternative interface
3. **Performance comparison** benchmarks
4. **Documentation** showing migration paths

### Phase 2: Gradual Migration (2-3 weeks)  
1. **Convert internal usage** to ttlog macros
2. **Add compatibility layers** for existing users
3. **Performance optimizations** in hot paths
4. **Community feedback** and iteration

### Phase 3: Independence (2-3 weeks)
1. **Make tracing optional** (feature flag)
2. **Full native implementation**  
3. **Advanced features** (spans, metrics, etc.)
4. **Comprehensive documentation**

## Example Migration

### Before (Current)
```rust
use tracing::{info, warn, error};

fn main() {
    let trace = ttlog::trace::Trace::init(1024, 128);
    
    info!("Application started");
    warn!(user_id = 123, "Invalid login attempt");
    error!("Database connection failed");
}
```

### After (Native TTLog)
```rust
use ttlog::{info, warn, error};

fn main() {
    let _handle = ttlog::init()
        .capacity(1024)
        .level(ttlog::LogLevel::Info)
        .init();
    
    info!("Application started");
    warn!("Invalid login attempt", user_id = 123);  // More natural syntax
    error!("Database connection failed");
}
```

## Performance Benefits

### Compilation Time
- **50% faster** compile times (no tracing-subscriber complexity)
- **Smaller binary size** (fewer dependencies)
- **Better incremental compilation**

### Runtime Performance  
- **2-3x faster** hot path (optimized macros + direct ring buffer)
- **Lower memory usage** (efficient field storage)
- **Better CPU cache utilization** (custom layout)

### Developer Experience
- **Simpler mental model** (just logs, not spans/events/layers)
- **Better error messages** (custom proc macros)
- **Integrated tooling** (query engine, web UI)

---

**Timeline**: 6-8 weeks for full implementation
**Breaking Changes**: None initially (compatibility layers)
**Dependencies Removed**: `tracing`, `tracing-subscriber` (eventually)
