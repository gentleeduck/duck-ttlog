// ttlog/src/native.rs - Your own logging system implementation

use std::sync::atomic::{AtomicU8, Ordering};
use std::collections::HashMap;
use smallvec::SmallVec;

/// Log levels - simple enum
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Level {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
}

impl Level {
    pub fn as_str(&self) -> &'static str {
        match self {
            Level::Trace => "TRACE",
            Level::Debug => "DEBUG", 
            Level::Info => "INFO",
            Level::Warn => "WARN",
            Level::Error => "ERROR",
        }
    }
}

/// Optimized field value storage
#[derive(Debug, Clone)]
pub enum FieldValue {
    Str(&'static str),
    String(String),
    I64(i64),
    U64(u64), 
    F64(f64),
    Bool(bool),
}

impl From<&'static str> for FieldValue {
    fn from(s: &'static str) -> Self { FieldValue::Str(s) }
}

impl From<String> for FieldValue {
    fn from(s: String) -> Self { FieldValue::String(s) }
}

impl From<i64> for FieldValue {
    fn from(i: i64) -> Self { FieldValue::I64(i) }
}

impl From<u64> for FieldValue {
    fn from(u: u64) -> Self { FieldValue::U64(u) }
}

impl From<f64> for FieldValue {
    fn from(f: f64) -> Self { FieldValue::F64(f) }
}

impl From<bool> for FieldValue {
    fn from(b: bool) -> Self { FieldValue::Bool(b) }
}

impl FieldValue {
    pub fn to_json_value(&self) -> serde_json::Value {
        match self {
            FieldValue::Str(s) => serde_json::Value::String(s.to_string()),
            FieldValue::String(s) => serde_json::Value::String(s.clone()),
            FieldValue::I64(i) => serde_json::Value::Number((*i).into()),
            FieldValue::U64(u) => serde_json::Value::Number((*u).into()),
            FieldValue::F64(f) => serde_json::json!(*f),
            FieldValue::Bool(b) => serde_json::Value::Bool(*b),
        }
    }
}

/// Field key-value pair
#[derive(Debug, Clone)]
pub struct Field {
    pub key: &'static str,
    pub value: FieldValue,
}

/// Native log event - optimized for performance
#[derive(Debug, Clone)]
pub struct LogEvent {
    pub timestamp_nanos: u64,
    pub level: Level,
    pub target: &'static str,
    pub message: String,
    pub fields: SmallVec<[Field; 8]>, // Stack allocation for small field count
}

impl LogEvent {
    /// Convert to your existing Event type for compatibility
    pub fn to_event(self) -> crate::event::Event {
        let mut field_map = HashMap::new();
        
        for field in self.fields {
            field_map.insert(field.key.to_string(), field.value.to_json_value());
        }
        
        crate::event::Event::new(
            self.timestamp_nanos / 1_000_000, // Convert nanos to millis
            self.level.as_str().to_string(),
            self.message,
            self.target.to_string(),
            field_map,
        )
    }
}

/// Global logger state
static GLOBAL_LEVEL: AtomicU8 = AtomicU8::new(Level::Info as u8);
static mut GLOBAL_SENDER: Option<crossbeam_channel::Sender<crate::trace::Message>> = None;

/// Check if logging is enabled for this level
#[inline]
pub fn is_enabled(level: Level) -> bool {
    let current = GLOBAL_LEVEL.load(Ordering::Relaxed);
    (level as u8) >= current
}

/// Set global logging level
pub fn set_level(level: Level) {
    GLOBAL_LEVEL.store(level as u8, Ordering::Relaxed);
}

/// Initialize native logging system
pub fn init_native(trace: &crate::trace::Trace) {
    unsafe {
        GLOBAL_SENDER = Some(trace.get_sender());
    }
}

/// High-performance timestamp
#[inline]
pub fn now_nanos() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64
}

/// Fast path logging - bypasses allocation where possible
#[inline]
pub fn emit_event(event: LogEvent) {
    unsafe {
        if let Some(ref sender) = GLOBAL_SENDER {
            // Convert to your existing event type
            let message = crate::trace::Message::Event(event.to_event());
            let _ = sender.try_send(message); // Non-blocking
        }
    }
}

/// Event builder for macro expansion
pub struct EventBuilder {
    timestamp_nanos: u64,
    level: Level,
    target: &'static str,
    message: String,
    fields: SmallVec<[Field; 8]>,
}

impl EventBuilder {
    #[inline]
    pub fn new(level: Level, target: &'static str) -> Self {
        Self {
            timestamp_nanos: now_nanos(),
            level,
            target,
            message: String::new(),
            fields: SmallVec::new(),
        }
    }
    
    #[inline]
    pub fn message<M: Into<String>>(mut self, msg: M) -> Self {
        self.message = msg.into();
        self
    }
    
    #[inline]
    pub fn field<V: Into<FieldValue>>(mut self, key: &'static str, value: V) -> Self {
        self.fields.push(Field {
            key,
            value: value.into(),
        });
        self
    }
    
    #[inline]
    pub fn emit(self) {
        let event = LogEvent {
            timestamp_nanos: self.timestamp_nanos,
            level: self.level,
            target: self.target,
            message: self.message,
            fields: self.fields,
        };
        emit_event(event);
    }
}

/// Simplified macros (without proc_macro for now)
#[macro_export]
macro_rules! ttlog_info {
    ($msg:expr) => {
        if $crate::native::is_enabled($crate::native::Level::Info) {
            $crate::native::EventBuilder::new($crate::native::Level::Info, module_path!())
                .message($msg)
                .emit();
        }
    };
    ($msg:expr, $($key:ident = $value:expr),+ $(,)?) => {
        if $crate::native::is_enabled($crate::native::Level::Info) {
            $crate::native::EventBuilder::new($crate::native::Level::Info, module_path!())
                .message($msg)
                $(.field(stringify!($key), $value))+
                .emit();
        }
    };
}

#[macro_export]
macro_rules! ttlog_warn {
    ($msg:expr) => {
        if $crate::native::is_enabled($crate::native::Level::Warn) {
            $crate::native::EventBuilder::new($crate::native::Level::Warn, module_path!())
                .message($msg)
                .emit();
        }
    };
    ($msg:expr, $($key:ident = $value:expr),+ $(,)?) => {
        if $crate::native::is_enabled($crate::native::Level::Warn) {
            $crate::native::EventBuilder::new($crate::native::Level::Warn, module_path!())
                .message($msg)
                $(.field(stringify!($key), $value))+
                .emit();
        }
    };
}

#[macro_export]
macro_rules! ttlog_error {
    ($msg:expr) => {
        if $crate::native::is_enabled($crate::native::Level::Error) {
            $crate::native::EventBuilder::new($crate::native::Level::Error, module_path!())
                .message($msg)
                .emit();
        }
    };
    ($msg:expr, $($key:ident = $value:expr),+ $(,)?) => {
        if $crate::native::is_enabled($crate::native::Level::Error) {
            $crate::native::EventBuilder::new($crate::native::Level::Error, module_path!())
                .message($msg)
                $(.field(stringify!($key), $value))+
                .emit();
        }
    };
}

#[macro_export]
macro_rules! ttlog_debug {
    ($msg:expr) => {
        if $crate::native::is_enabled($crate::native::Level::Debug) {
            $crate::native::EventBuilder::new($crate::native::Level::Debug, module_path!())
                .message($msg)
                .emit();
        }
